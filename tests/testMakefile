#------------------------------------------------------------------------------
#
# SYNOPSIS
#   testMakefile -- Basic tests for a generic CS253 Makefile
#
# USAGE
#   testMakefile exe points
#
#     exe -    Name of the expected executable program's file
#     points - Number of points awarded to the assigned project
#
# DESCRIPTION
#   Runs basic tests for a generic CS253 Makefile using GNU make and onyx.
#   Can be invoked from a grading script to exercise any project's build.
#
#   Exit status is the number of points deducted
#   for Makefile defects.
#
# TEST CASES
#   make
#   make clean
#   Use of CFLAGS
#   -std=c99
#   -Wall
#   Default target builds the named executable program
#   Default target builds without warnings or error messages
#
# ERRORS
#   If the test cannot be executed, the script writes an error message to
#   stderr and exits with maximum points
#
#------------------------------------------------------------------------------


#Initialization
let pointsLost=0




#--------------------------------------------------------------------------------
# Define function to log a message to stderr
# Usage:  logMsg $LINENO messageText
#--------------------------------------------------------------------------------
logMsg() {
  1>&2 echo "[$1] " "$2"
}




#---------------------------------------------------------------------------------
# Define function to deduct points if the specified file exists
# Usage:  deductFileExists $LINENO filename nPoints
#---------------------------------------------------------------------------------
deductFileExists() {
  if [ -e "$2" ]; then
    deductPoints $1 $3
    logMsg "$1" "ERROR:  Unexpected file '$2'.  Deduct $3 points"
  fi
}


#---------------------------------------------------------------------------------
# Define function to deduct points if regexp is missing from string.  Ignores
# case.
# Usage:  deductMissingString $LINENO string regexp nPoints
#---------------------------------------------------------------------------------
deductMissingString() {
  if ! echo "$2" | grep -i -q "$3" ; then
    deductPoints $1 $4
    logMsg "$1" "ERROR:  Substring '$3' missing in string, '$2'."
  fi
}




#---------------------------------------------------------------------------------
# Define function to deduct points if regexp appears in string.  Ignores
# case.
# Usage:  deductMissingString $LINENO string regexp nPoints
#---------------------------------------------------------------------------------
deductString() {
  if echo "$2" | grep -i -q "$3" ; then
    deductPoints $1 $4
    logMsg "$1" "ERROR:  Regexp '$3' unexpectedly appears in string, '$2'."
  fi
}





#---------------------------------------------------------------------------------
# Define function to deduct points if regexp is missing from a specified file
# Usage:  deductnGrep $LINENO regexp filename nPoints
#---------------------------------------------------------------------------------
deductnGrep() {
  output=$(grep -i "$2" "$3")
  if [ "$?" != 0 ]; then
    deductPoints $1 $4
    logMsg "$1" "ERROR:  Could not grep regexp '$2' in '$3'."
  fi
}






#---------------------------------------------------------------------------------
# Define function to deduct points (accumulated in $pointsLost)
# Usage:  deductPoints $LINENO nPoints
#---------------------------------------------------------------------------------
deductPoints() {
  let pointsLost+=$2
  if [ $pointsLost -gt $MAXPOINTS ]; then
    let pointsLost=$MAXPOINTS
  fi
  logMsg $1 "Deducting $2 points"
}




#--------------------------------------------------------------------------------
# Grading starts here
#--------------------------------------------------------------------------------

#Verify the expected number of command-line arguments
if [ $# -ne 2 ]; then
   >&2 echo "USAGE:  $0 exe points"
   exit $MAXPOINTS
fi

#Process the command-line arguments
EXE=$1
MAXPOINTS=$2

#Initialization
let LETTERGRADE=MAXPOINTS/10
let HALFLETTERGRADE=MAXPOINTS/20

#Document where we are grading
project=`pwd`
logMsg $LINENO "Grading contents of $project with $0"

#Manually clean the project folder of build artifacts
rm -f *.o *.d $EXE

#Test build default target
logMsg $LINENO "Running make"
result=$( make 2>&1 )

#Verify make actually built the executable program
logMsg $LINENO "Grading make default target"
if [ ! -x $EXE ]; then
   logMsg $LINENO "FATAL:  make did not build $EXE"
   deductPoints $LINENO $MAXPOINTS
   echo $pointsLost
   exit $MAXPOINTS
fi

#Verify make ran without warnings
logMsg $LINENO "Grading make ran without warnings"
deductString $LINENO "$result" "warning" $HALFLETTERGRADE

#Verify make ran without errors
logMsg $LINENO "Grading make ran without errors"
deductString $LINENO "$results" "error" $LETTERGRADE

#Verify configuration of CFLAGS with -Wall and -std=c99
logMsg $LINENO "Grading configuration of Makefile with CFLAGS = -Wall -std=c99"
deductnGrep $LINENO "CFLAGS" Makefile $HALFLETTERGRADE
deductnGrep $LINENO "Wall"   Makefile $HALFLETTERGRADE
deductnGrep $LINENO "c99"    Makefile $HALFLETTERGRADE

#Verify make clean removes binary build artifacts
logMsg $LINENO "Grading make clean"
make clean
result=$( ls *.o 2>&1 )
deductMissingString $LINENO "$result" "No such file" $HALFLETTERGRADE
result=$( ls $EXE 2>&1 )
deductMissingString $LINENO "$result" "No such file" $HALFLETTERGRADE

#Verify make does nothing if the product is already built (see man make for explanation of -q option)
logMsg $LINENO "Grading make does nothing when product is already up-to-date"
make
make -q
if [ "$?" -ne "0" ]; then
   logMsg $LINENO "ERROR:  Make should do nothing when product is alredy up-to-date"
   deductPoints $LINENO $HALFLETTERGRADE
fi



#------------------------------------------------------------------------------
# Grading ends here
#------------------------------------------------------------------------------
logMsg $LINENO "Note:  $0 ends.  Deducted $pointsLost points"
exit $pointsLost

